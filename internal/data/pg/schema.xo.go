// Package pg contains generated code for schema 'public'.
package pg

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"github.com/rarimo/rarime-link-svc/internal/data"

	"gitlab.com/distributed_lab/kit/pgdb"
	"gitlab.com/distributed_lab/logan/v3/errors"
)

// Storage is the helper struct for database operations
type Storage struct {
	db *pgdb.DB
}

func (s *Storage) ProofLinkQ() data.ProofLinkQ {
	return NewLinkQ(s.db)
}

// New - returns new instance of storage
func New(db *pgdb.DB) *Storage {
	return &Storage{
		db,
	}
}

// DB - returns db used by Storage
func (s *Storage) DB() *pgdb.DB {
	return s.db
}

// Clone - returns new storage with clone of db
func (s *Storage) Clone() data.Storage {
	return New(s.db.Clone())
}

// Transaction begins a transaction on repo.
func (s *Storage) Transaction(tx func() error) error {
	return s.db.Transaction(tx)
} // GorpMigrationQ represents helper struct to access row of 'gorp_migrations'.
type GorpMigrationQ struct {
	db *pgdb.DB
}

// NewGorpMigrationQ  - creates new instance
func NewGorpMigrationQ(db *pgdb.DB) GorpMigrationQ {
	return GorpMigrationQ{
		db,
	}
}

// GorpMigrationQ  - creates new instance of GorpMigrationQ
func (s Storage) GorpMigrationQ() data.GorpMigrationQ {
	return NewGorpMigrationQ(s.DB())
}

var colsGorpMigration = `id, applied_at`

// InsertCtx inserts a GorpMigration to the database.
func (q GorpMigrationQ) InsertCtx(ctx context.Context, gm *data.GorpMigration) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.gorp_migrations (` +
		`id, applied_at` +
		`) VALUES (` +
		`$1, $2` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, gm.ID, gm.AppliedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a GorpMigration to the database.
func (q GorpMigrationQ) Insert(gm *data.GorpMigration) error {
	return q.InsertCtx(context.Background(), gm)
}

// UpdateCtx updates a GorpMigration in the database.
func (q GorpMigrationQ) UpdateCtx(ctx context.Context, gm *data.GorpMigration) error {
	// update with composite primary key
	sqlstr := `UPDATE public.gorp_migrations SET ` +
		`applied_at = $1 ` +
		`WHERE id = $2`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, gm.AppliedAt, gm.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a GorpMigration in the database.
func (q GorpMigrationQ) Update(gm *data.GorpMigration) error {
	return q.UpdateCtx(context.Background(), gm)
}

// UpsertCtx performs an upsert for GorpMigration.
func (q GorpMigrationQ) UpsertCtx(ctx context.Context, gm *data.GorpMigration) error {
	// upsert
	sqlstr := `INSERT INTO public.gorp_migrations (` +
		`id, applied_at` +
		`) VALUES (` +
		`$1, $2` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`applied_at = EXCLUDED.applied_at `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, gm.ID, gm.AppliedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for GorpMigration.
func (q GorpMigrationQ) Upsert(gm *data.GorpMigration) error {
	return q.UpsertCtx(context.Background(), gm)
}

// DeleteCtx deletes the GorpMigration from the database.
func (q GorpMigrationQ) DeleteCtx(ctx context.Context, gm *data.GorpMigration) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.gorp_migrations ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, gm.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the GorpMigration from the database.
func (q GorpMigrationQ) Delete(gm *data.GorpMigration) error {
	return q.DeleteCtx(context.Background(), gm)
} // ProofQ represents helper struct to access row of 'proofs'.
type ProofQ struct {
	db *pgdb.DB
}

// NewProofQ  - creates new instance
func NewProofQ(db *pgdb.DB) ProofQ {
	return ProofQ{
		db,
	}
}

// ProofQ  - creates new instance of ProofQ
func (s Storage) ProofQ() data.ProofQ {
	return NewProofQ(s.DB())
}

var colsProof = `id, creator, created_at, proof`

// InsertCtx inserts a Proof to the database.
func (q ProofQ) InsertCtx(ctx context.Context, p *data.Proof) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.proofs (` +
		`creator, created_at, proof` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) RETURNING id`
		// run

	err := q.db.GetRawContext(ctx, &p.ID, sqlstr, p.Creator, p.CreatedAt, p.Proof)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// Insert insert a Proof to the database.
func (q ProofQ) Insert(p *data.Proof) error {
	return q.InsertCtx(context.Background(), p)
}

// UpdateCtx updates a Proof in the database.
func (q ProofQ) UpdateCtx(ctx context.Context, p *data.Proof) error {
	// update with composite primary key
	sqlstr := `UPDATE public.proofs SET ` +
		`creator = $1, proof = $2 ` +
		`WHERE id = $3`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, p.Creator, p.Proof, p.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a Proof in the database.
func (q ProofQ) Update(p *data.Proof) error {
	return q.UpdateCtx(context.Background(), p)
}

// UpsertCtx performs an upsert for Proof.
func (q ProofQ) UpsertCtx(ctx context.Context, p *data.Proof) error {
	// upsert
	sqlstr := `INSERT INTO public.proofs (` +
		`id, creator, created_at, proof` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`creator = EXCLUDED.creator, proof = EXCLUDED.proof `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, p.ID, p.Creator, p.CreatedAt, p.Proof); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for Proof.
func (q ProofQ) Upsert(p *data.Proof) error {
	return q.UpsertCtx(context.Background(), p)
}

// DeleteCtx deletes the Proof from the database.
func (q ProofQ) DeleteCtx(ctx context.Context, p *data.Proof) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.proofs ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, p.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the Proof from the database.
func (q ProofQ) Delete(p *data.Proof) error {
	return q.DeleteCtx(context.Background(), p)
}

// GorpMigrationByIDCtx retrieves a row from 'public.gorp_migrations' as a GorpMigration.
//
// Generated from index 'gorp_migrations_pkey'.
func (q GorpMigrationQ) GorpMigrationByIDCtx(ctx context.Context, id string, isForUpdate bool) (*data.GorpMigration, error) {
	// query
	sqlstr := `SELECT ` +
		`id, applied_at ` +
		`FROM public.gorp_migrations ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.GorpMigration
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// GorpMigrationByID retrieves a row from 'public.gorp_migrations' as a GorpMigration.
//
// Generated from index 'gorp_migrations_pkey'.
func (q GorpMigrationQ) GorpMigrationByID(id string, isForUpdate bool) (*data.GorpMigration, error) {
	return q.GorpMigrationByIDCtx(context.Background(), id, isForUpdate)
}

// ProofByIDCtx retrieves a row from 'public.proofs' as a Proof.
//
// Generated from index 'proofs_pkey'.
func (q ProofQ) ProofByIDCtx(ctx context.Context, id int, isForUpdate bool) (*data.Proof, error) {
	// query
	sqlstr := `SELECT ` +
		`id, creator, created_at, proof ` +
		`FROM public.proofs ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Proof
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// ProofByID retrieves a row from 'public.proofs' as a Proof.
//
// Generated from index 'proofs_pkey'.
func (q ProofQ) ProofByID(id int, isForUpdate bool) (*data.Proof, error) {
	return q.ProofByIDCtx(context.Background(), id, isForUpdate)
}

// ProofsByUserDIDCtx retrieves all proofs for a given userDID from 'public.proofs'.
func (q ProofQ) ProofsByUserDIDCtx(ctx context.Context, userDID string, isForUpdate bool) ([]data.Proof, error) {
	// query
	sqlstr := `SELECT ` +
		`id, creator, created_at, proof ` +
		`FROM public.proofs ` +
		`WHERE creator = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var proofs []data.Proof
	err := q.db.SelectRawContext(ctx, &proofs, sqlstr, userDID)
	if err != nil {
		return nil, errors.Wrap(err, "failed to execute select")
	}

	return proofs, nil
}

// ProofsByUserDID retrieves all proofs for a given userDID from 'public.proofs'.
func (q ProofQ) ProofsByUserDID(userDID string, isForUpdate bool) ([]data.Proof, error) {
	return q.ProofsByUserDIDCtx(context.Background(), userDID, isForUpdate)
}

// SelectAllCtx retrieves all rows from 'public.proofs'.
func (q ProofQ) SelectAllCtx(ctx context.Context) ([]*data.Proof, error) {
	// query
	sqlstr := `SELECT ` +
		`id, creator, created_at, proof ` +
		`FROM public.proofs`
	// run
	var proofs []*data.Proof
	err := q.db.SelectRawContext(ctx, &proofs, sqlstr)
	if err != nil {
		return nil, errors.Wrap(err, "failed to execute select")
	}

	return proofs, nil
}

// SelectAll retrieves all rows from 'public.proofs'.
func (q ProofQ) SelectAll() ([]*data.Proof, error) {
	return q.SelectAllCtx(context.Background())
}

// DeleteCtx deletes the Proof from the database by ID.
func (q ProofQ) DeleteByIDCtx(ctx context.Context, id int) error {
	// delete with single primary key
	sqlstr := `DELETE ` +
		`FROM public.proofs ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, id); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// DeleteByID deletes the Proof from the database by ID.
func (q ProofQ) DeleteByID(id int) error {
	return q.DeleteByIDCtx(context.Background(), id)
}


// GetProofsByIDs retrieves all proofs for a given userDID from 'public.proofs'.
func (q ProofQ) GetProofByID(proofIDs int) (data.Proof, error) {
	// query
	sqlstr := `SELECT ` +
		`id, creator, created_at, proof ` +
		`FROM public.proofs ` +
		`WHERE id = $1`
	// run
	var proof data.Proof
	err := q.db.GetRaw(&proof, sqlstr, proofIDs)
	if err != nil {
		return proof, errors.Wrap(err, "failed to execute select")
	}

	return proof, nil
}

// LinkQ represents helper struct to access row of 'links'.
type LinkQ struct {
	db *pgdb.DB
}

// NewLinkQ  - creates new instance
func NewLinkQ(db *pgdb.DB) LinkQ {
	return LinkQ{
		db,
	}
}

// LinkQ  - creates new instance of LinkQ
func (s Storage) LinkQ() data.ProofLinkQ {
	return NewLinkQ(s.DB())
}

// InsertCtx inserts a Link to the database.
func (q LinkQ) InsertCtx(ctx context.Context, l *data.Link) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.links (` +
		`id, index, created_at` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) RETURNING id`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, l.ID, l.Index, l.CreatedAt)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// SelectAllCtx retrieves all rows from 'public.links'.
func (q LinkQ) SelectAllCtx(ctx context.Context) ([]*data.Link, error) {
	// query
	sqlstr := `SELECT ` +
		`id, index, created_at ` +
		`FROM public.links`
	// run
	var links []*data.Link
	err := q.db.SelectRawContext(ctx, &links, sqlstr)
	if err != nil {
		return nil, errors.Wrap(err, "failed to execute select")
	}

	return links, nil
}

// SelectAll retrieves all rows from 'public.links'.
func (q LinkQ) SelectAll() ([]*data.Link, error) {
	return q.SelectAllCtx(context.Background())
}

// LinkToProofQ represents helper struct to access row of 'links_to_proofs'.
type LinkToProofQ struct {
	db *pgdb.DB
}

// NewLinkToProofQ  - creates new instance
func NewLinkToProofQ(db *pgdb.DB) LinkToProofQ {
	return LinkToProofQ{
		db,
	}
}

// LinkToProofQ  - creates new instance of LinkToProofQ
func (s Storage) LinkToProofQ() data.LinkToProofQ {
	return NewLinkToProofQ(s.DB())
}

// InsertCtx inserts a LinkToProof to the database.
func (q LinkToProofQ) InsertCtx(ctx context.Context, l *data.LinkToProof) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.links_to_proofs (` +
		`link_id` +
		`) VALUES (` +
		`$1` +
		`) RETURNING id`
	// run

	err := q.db.GetRawContext(ctx, &l.ID, sqlstr, l.LinkID)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// SelectAllCtx retrieves all rows from 'public.links_to_proofs'.
func (q LinkToProofQ) SelectAllCtx(ctx context.Context) ([]*data.LinkToProof, error) {
	// query
	sqlstr := `SELECT ` +
		`id, link_id ` +
		`FROM public.links_to_proofs`
	// run
	var linkToProofs []*data.LinkToProof
	err := q.db.SelectRawContext(ctx, &linkToProofs, sqlstr)
	if err != nil {
		return nil, errors.Wrap(err, "failed to execute select")
	}

	return linkToProofs, nil
}

// SelectAll retrieves all rows from 'public.links_to_proofs'.
func (q LinkToProofQ) SelectAll() ([]*data.LinkToProof, error) {
	return q.SelectAllCtx(context.Background())
}

// GetLastIndex retrieves the last index from 'public.links'.
func (q LinkQ) GetLastIndex() (int, error) {
	// query
	sqlstr := `SELECT ` +
		`index ` +
		`FROM public.links ` +
		`ORDER BY index DESC LIMIT 1`
	// run
	var index int
	err := q.db.GetRaw(&index, sqlstr)
	if sql.ErrNoRows == err {
		return -1, nil
	}
	if err != nil {
		return 0, errors.Wrap(err, "failed to execute select")
	}

	return index, nil
}

// Transaction begins a transaction on repo.
func (q LinkQ) Transaction(fn func(db data.ProofLinkQ) error) error {
	return q.db.Transaction(func() error{
		return fn(q)
	})
}

// GetProofsByIndex retrieves all proofs for a given userDID from 'public.proofs'.
func (q LinkQ) GetProofsByIndex(index int) ([]data.Link, error) {
	// query
	sqlstr := `SELECT ` +
		`id, index, created_at ` +
		`FROM public.links ` +
		`WHERE index = $1`
	// run
	var links []data.Link
	err := q.db.SelectRaw(&links, sqlstr, index)
	if err != nil {
		return nil, errors.Wrap(err, "failed to execute select")
	}

	return links, nil
}